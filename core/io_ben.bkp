/******************************************************************************
 *                                                                            *
 * IO.C                                                                       *
 *                                                                            *
 * HDF5 OUTPUT AND RESTART                                                    *
 *                                                                            *
 ******************************************************************************/

#include "decs.h"
#include <hdf5.h>

#define MAX_GRID_DIM (5)

void write_array(void *data, const char *name, hsize_t rank,
  hsize_t *fdims, hsize_t *fstart, hsize_t *fcount, hsize_t *mdims,
  hsize_t *mstart, hsize_t type);
void read_array(void *data, const char *name, hsize_t rank,
  hsize_t *fdims, hsize_t *fstart, hsize_t *fcount, hsize_t *mdims,
  hsize_t *mstart, hsize_t type);
hsize_t product_hsize_t(hsize_t a[], int size);

// Some macro tricks to drastically reduce number of lines of code
#define TYPE_FLOAT H5T_NATIVE_FLOAT
#define TYPE_DBL H5T_NATIVE_DOUBLE
#define TYPE_INT H5T_NATIVE_INT
#define TYPE_STR H5T_NATIVE_CHAR

#define WRITE_HDR(x, type) write_array((void*)&x, #x, 1, fdims_hdr, \
  fstart_hdr, fcount_hdr, mdims_hdr, mstart_hdr, type)
#define READ_HDR(x, type) read_array((void*)&x, #x, 1, fdims_hdr, \
  fstart_hdr, fcount_hdr, mdims_hdr, mstart_hdr, type)

#define WRITE_ARRAY(x, rank, fdims, fstart, fcount, mdims, mstart, type) \
  write_array((void*)x, #x, rank, fdims, fstart, fcount, mdims, mstart, type)
#define WRITE_GRID(x, type) write_array((void*)x, #x, 3, fdims_grid, \
  fstart_grid, fcount_grid, mdims_grid, mstart_grid, type)
#define WRITE_GRID_NO_GHOSTS(x, type) write_array((void*)x, #x, 3, fdims_grid, \
  fstart_grid, fcount_grid, mdims_grid_noghost, mstart_grid_noghost, type)

#define WRITE_VEC(x, type) write_array((void*)x, #x, 4, fdims_vec, \
  fstart_vec, fcount_vec, mdims_vec, mstart_vec, type)
#define WRITE_VEC_NO_GHOSTS(x, type) \
  write_array((void*)x, #x, 4, fdims_vec, \
  fstart_vec, fcount_vec, mdims_vec_noghost, mstart_vec_noghost, type)
#define WRITE_TENSOR(x, type) write_array((void*)x, #x, 5, fdims_tens, \
  fstart_tens, fcount_tens, mdims_tens, mstart_tens, type)
#define WRITE_TENSOR_NO_GHOSTS(x, type) \
  write_array((void*)x, #x, 5, fdims_tens,				\
  fstart_tens, fcount_tens, mdims_tens_noghost, mstart_tens_noghost, type)

hid_t file_id, plist_id;
hid_t filespace, memspace;
hid_t filespace_hdr, memspace_hdr;
hsize_t hdr_dims[1] = {1}, zero = 0, one = 1;
hsize_t mem_start[MAX_GRID_DIM], file_grid_start[MAX_GRID_DIM];
hsize_t file_grid_count[MAX_GRID_DIM], file_grid_dims[MAX_GRID_DIM];
hsize_t file_hdr_start[1] = {0}, file_hdr_count[1], file_hdr_dims[1] = {1};
hsize_t hdr_rank = 1, grid_rank;

hsize_t fdims_grid[3] = {N1TOT, N2TOT, N3TOT};
hsize_t fstart_grid[3];
hsize_t fcount_grid[3] = {N1, N2, N3};
hsize_t mdims_grid[3] = {N1+2*NG, N2+2*NG, N3+2*NG};
hsize_t mstart_grid[3] = {NG, NG, NG};

hsize_t mdims_grid_noghost[3] = {N1, N2, N3};
hsize_t mstart_grid_noghost[3] = {0, 0, 0};

hsize_t fdims_vec[4] = {N1TOT, N2TOT, N3TOT, NDIM};
hsize_t fstart_vec[4];
hsize_t fcount_vec[4] = {N1, N2, N3, NDIM};
hsize_t mdims_vec[4] = {N1+2*NG, N2+2*NG, N3+2*NG, NDIM};
hsize_t mstart_vec[4] = {NG, NG, NG, 0};

hsize_t mdims_vec_noghost[4] = {N1, N2, N3, NDIM};
hsize_t mstart_vec_noghost[4] = {0, 0, 0, 0};

hsize_t fdims_tens[5] = {N1TOT, N2TOT, N3TOT, NDIM, NDIM};
hsize_t fstart_tens[5];
hsize_t fcount_tens[5] = {N1, N2, N3, NDIM, NDIM};
hsize_t mdims_tens[5] = {N1+2*NG, N2+2*NG, N3+2*NG, NDIM, NDIM};
hsize_t mstart_tens[5] = {NG, NG, NG, 0, 0};

hsize_t mdims_tens_noghost[5] = {N1, N2, N3, NDIM, NDIM};
hsize_t mstart_tens_noghost[5] = {0, 0, 0, 0, 0};

hsize_t fdims_hdr[1] = {1};
hsize_t fstart_hdr[1] = {0};
hsize_t fcount_hdr[1] = {1};
hsize_t mdims_hdr[1] = {1};
hsize_t mstart_hdr[1] = {0};

hid_t phfiletype, phmemtype, trackphfiletype, trackphmemtype;

const char *vnams_base[] = {"RHO", "UU", "U1", "U2", "U3", "B1", "B2", "B3"};
const char *vnams[NVAR];
//static char version[STRLEN];
static int dump_id = 0, fdump_id = 0; //restart_id = 0, restart_perm_id = 0
static GridDouble divb;
#if OUTPUT_EOSVARS
static grid_double_type PRESS, ENT, TEMP;
#endif

void noop(double ***array) {

}

void init_io()
{
  strcpy(dumpdir, "dumps/");
  strcpy(restartdir, "restarts/");
  //strcpy(xmfdir, "dumps/xmf/"); //TODO reintroduce this?

  if (mpi_io_proc()) { // TODO may be in main too
    char mkdircall[STRLEN];
    strcpy(mkdircall, "mkdir -p ");
    strcat(mkdircall, dumpdir);
    strcat(mkdircall, " ");
    strcat(mkdircall, restartdir);
    //strcat(mkdircall, " ");
    //strcat(mkdircall, xmfdir);
    safe_system(mkdircall);
  }

  fstart_grid[0] = global_start[0];
  fstart_grid[1] = global_start[1];
  fstart_grid[2] = global_start[2];
  fstart_vec[0] = global_start[0];
  fstart_vec[1] = global_start[1];
  fstart_vec[2] = global_start[2];
  fstart_vec[3] = 0;
  fstart_tens[0] = global_start[0];
  fstart_tens[1] = global_start[1];
  fstart_tens[2] = global_start[2];
  fstart_tens[3] = 0;
  fstart_tens[4] = 0;
  if (!mpi_io_proc()) fcount_hdr[0] = 0;

  filespace_hdr = H5Screate_simple(1, file_hdr_dims, NULL);
  file_hdr_count[0] = (mpi_io_proc() ? one : zero);
  H5Sselect_hyperslab(filespace_hdr, H5S_SELECT_SET, file_hdr_start, NULL,
    file_hdr_count, NULL);
  memspace_hdr = H5Screate_simple(hdr_rank, file_hdr_count, NULL);

  PLOOP {
    vnams[ip] = vnams_base[ip];
  }
//  PASSLOOP {
//    vnams[ipass] = PASSNAME(ipass);
//  }
  #if ELECTRONS
  vnams[KEL] = "KEL";
  vnams[KTOT] = "KTOT";
  #endif // ELECTRONS
}

void dump_grid(struct GridGeom *G)
{
  char name[STRLEN], fname[STRLEN];
  sprintf(fname, "grid.h5");
  strcpy(name, dumpdir);
  strcat(name, fname);
  if (mpi_io_proc()) {
    fprintf(stdout, "WRITING GEOMETRY TO %s\n", name);
  }

  hid_t plist_id = H5Pcreate(H5P_FILE_ACCESS);
  H5Pset_fapl_mpio(plist_id, MPI_COMM_WORLD, MPI_INFO_NULL);
  file_id = H5Fcreate(name, H5F_ACC_TRUNC, H5P_DEFAULT, plist_id);
  if (file_id < 0) {
    fprintf(stderr, "Could not create grid file! Exiting...\n");
    exit(-1);
  }
  H5Pclose(plist_id);
  
  {
    double *Xharm = malloc(N1*N2*N3*NDIM*sizeof(double));
    int n = 0;
    ZLOOP_OUT
    {
      coord(i, j, k, CENT, &Xharm[n]);
      n += 4;
    }
    WRITE_VEC_NO_GHOSTS(Xharm, TYPE_DBL);
    free(Xharm);
  }

  { // If metric == Minkowski, then Xcart == Xharm
    double *Xcart = malloc(N1*N2*N3*NDIM*sizeof(double));
    double X[NDIM],Xcart_loc[NDIM];
    int n = 0;
    ZLOOP_OUT {
      coord(i, j, k, CENT, X);
      //cart_coord(X,Xcart_loc);
      /*
      #if METRIC == MKS
      { // poles should be at theta = 0 and pi
	// TODO: is this right? Maybe causes a weird offset.
	if (global_start[1] == 0 && j == NG) Xcart_loc[2] = 0;
	if (global_stop[1] == N2TOT && j == N2 + NG) Xcart_loc[2] = M_PI;
      }
      #endif // METRIC
      */
      for (int l = 0; l < NDIM; l++) Xcart[n+l] = Xcart_loc[l];
      n += 4;
    }
    WRITE_VEC_NO_GHOSTS(Xcart, TYPE_DBL);
    free(Xcart);
  }

  { // Face locations, in HARM and Cartesoan coordinates
    #define RANK (4)
    // metadata
    hsize_t fdims[RANK] = {N1TOT+1, N2TOT+1, N3TOT+1, NDIM};
    hsize_t fstart[RANK] = {global_start[0],global_start[1],global_start[2],0};
    hsize_t fcount[RANK] = {N1, N2, N3, NDIM};
    hsize_t mdims[RANK] = {N1, N2, N3, NDIM};
    for (int d = 0; d < 3; d++) {
      if (global_stop[d] == fdims[d]-1) {
	fcount[d]++;
	mdims[d]++;
      }
    }
    hsize_t mstart[RANK] = {0, 0, 0, 0};
    hsize_t memsize_tot = product_hsize_t(mdims, RANK);
    // Values
    double *XFharm = malloc(memsize_tot*sizeof(double));
    double *XFcart = malloc(memsize_tot*sizeof(double));
    double X[NDIM], Xcart_loc[NDIM];
    int n = 0;
    ZSLOOP(0, mdims[0]-1, 0, mdims[1]-1, 0, mdims[2]-1) {
      coord(i, j, k, CORN, X);
      cart_coord(X, Xcart_loc);
      for (int l = 0; l < NDIM; l++) {
	XFharm[n+l] = X[l];
	XFcart[n+l] = Xcart_loc[l];
      }
      n += 4;
    }
    WRITE_ARRAY(XFharm, RANK, fdims, fstart, fcount, mdims, mstart, TYPE_DBL);
    WRITE_ARRAY(XFcart, RANK, fdims, fstart, fcount, mdims, mstart, TYPE_DBL);
    free(XFharm);
    free(XFcart);
    #undef RANK
  }
 
  #if METRIC == MKS
  {
    double *Xbl = malloc(N1*N2*N3*NDIM*sizeof(double));
    int n = 0;
    ZLOOP_OUT
    {
      double X[NDIM], r, th;
      coord(i, j, k, CENT, X);
      bl_coord(X, &r, &th);
      Xbl[n+1] = r;
      Xbl[n+2] = th;
      Xbl[n+3] = X[3];
      n += 4;
    }
    WRITE_VEC_NO_GHOSTS(Xbl, TYPE_DBL);
    free(Xbl);
  }
  #endif
  
  {
    double *gcov = malloc(N1*N2*N3*NDIM*NDIM*sizeof(double));
    int n = 0;
    ZLOOP_OUT {
      DLOOP2 {
	gcov[n] = G->gcov[CENT][mu][nu][j][i];
	n++;
      }
    }
    WRITE_TENSOR_NO_GHOSTS(gcov, TYPE_DBL);
    free(gcov);
  }
  
  {
    double *gcon = malloc(N1*N2*N3*NDIM*NDIM*sizeof(double));
    int n = 0;
    ZLOOP_OUT {
      DLOOP2 {
	gcon[n] = G->gcon[CENT][mu][nu][j][i];
	n++;
      }
    }
    WRITE_TENSOR_NO_GHOSTS(gcon, TYPE_DBL);
    free(gcon);
  }
  
  {
    double *gdet = malloc(N1*N2*N3*sizeof(double));
    int n = 0;
    ZLOOP_OUT {
      gdet[n] = G->gdet[CENT][j][i];
      n++;
    }
    WRITE_GRID_NO_GHOSTS(gdet, TYPE_DBL);
    free(gdet);
  }

  {
    double *alpha = malloc(N1*N2*N3*sizeof(double));
    int n = 0;
    ZLOOP_OUT {
      alpha[n] = G->lapse[CENT][j][i];
      n++;
    }
    WRITE_GRID_NO_GHOSTS(alpha, TYPE_DBL);
    free(alpha);
  }

  // TODO output all this grid stuff?
//  #if METRIC == MKS
//  {
//    double X[NDIM];
//    double Lambda_con_local[NDIM][NDIM];
//    double Lambda_cov_local[NDIM][NDIM];
//    double *Lambda_h2bl_con = malloc(N1*N2*N3*NDIM*NDIM*sizeof(double));
//    double *Lambda_h2bl_cov = malloc(N1*N2*N3*NDIM*NDIM*sizeof(double));
//    int n = 0;
//    ZLOOP_OUT {
//      coord(i, j, k, CENT, X);
//      jac_harm_to_bl(X, Lambda_cov_local, Lambda_con_local);
//      DLOOP2 {
//	Lambda_h2bl_con[n] = Lambda_con_local[mu][nu];
//	Lambda_h2bl_cov[n] = Lambda_cov_local[mu][nu];
//	n++;
//      }
//    }
//    WRITE_TENSOR_NO_GHOSTS(Lambda_h2bl_con, TYPE_DBL);
//    WRITE_TENSOR_NO_GHOSTS(Lambda_h2bl_cov, TYPE_DBL);
//    free(Lambda_h2bl_con);
//    free(Lambda_h2bl_cov);
//  }
//
//  {
//    double X[NDIM];
//    double Lambda_con_local[NDIM][NDIM];
//    double Lambda_cov_local[NDIM][NDIM];
//    double *Lambda_bl2cart_con = malloc(N1*N2*N3*NDIM*NDIM*sizeof(double));
//    double *Lambda_bl2cart_cov = malloc(N1*N2*N3*NDIM*NDIM*sizeof(double));
//    int n = 0;
//    ZLOOP_OUT {
//      coord(i, j, k, CENT, X);
//      jac_bl_to_cart(X, Lambda_cov_local, Lambda_con_local);
//      DLOOP2 {
//	Lambda_bl2cart_con[n] = Lambda_con_local[mu][nu];
//	Lambda_bl2cart_cov[n] = Lambda_cov_local[mu][nu];
//	n++;
//      }
//    }
//    WRITE_TENSOR_NO_GHOSTS(Lambda_bl2cart_con, TYPE_DBL);
//    WRITE_TENSOR_NO_GHOSTS(Lambda_bl2cart_cov, TYPE_DBL);
//    free(Lambda_bl2cart_con);
//    free(Lambda_bl2cart_cov);
//  }
//  #endif // METRIC == MKS

//  {
//    double X[NDIM];
//    double Lambda_con_local[NDIM][NDIM];
//    double Lambda_cov_local[NDIM][NDIM];
//    double *Lambda_h2cart_con = malloc(N1*N2*N3*NDIM*NDIM*sizeof(double));
//    double *Lambda_h2cart_cov = malloc(N1*N2*N3*NDIM*NDIM*sizeof(double));
//    int n = 0;
//    ZLOOP_OUT {
//      coord(i, j, k, CENT, X);
//      jac_harm_to_cart(X, Lambda_cov_local, Lambda_con_local);
//      DLOOP2 {
//	Lambda_h2cart_con[n] = Lambda_con_local[mu][nu];
//	Lambda_h2cart_cov[n] = Lambda_cov_local[mu][nu];
//	n++;
//      }
//    }
//    WRITE_TENSOR_NO_GHOSTS(Lambda_h2cart_con, TYPE_DBL);
//    WRITE_TENSOR_NO_GHOSTS(Lambda_h2cart_cov, TYPE_DBL);
//    free(Lambda_h2cart_con);
//    free(Lambda_h2cart_cov);
//  }

  H5Fflush(file_id, H5F_SCOPE_GLOBAL);
  H5Fclose(file_id);
}

void dump(struct GridGeom *G, struct FluidState *S)
{
//  timer_start(TIMER_OUT); // TODO reinstate

  char name[STRLEN], fname[STRLEN];
  sprintf(fname, "dump_%08d.h5", dump_id);
  strcpy(name, dumpdir);
  strcat(name, fname);
  if (mpi_io_proc()) {
    fprintf(stdout, "DUMP %s\n", name);
  }
  hid_t plist_id = H5Pcreate(H5P_FILE_ACCESS);
  H5Pset_fapl_mpio(plist_id, MPI_COMM_WORLD, MPI_INFO_NULL);
  file_id = H5Fcreate(name, H5F_ACC_TRUNC, H5P_DEFAULT, plist_id);
  if (file_id < 0) {
    fprintf(stderr, "Could not create dump file! Exiting...\n");
    exit(-1);
  }
  H5Pclose(plist_id);

  //write_hdr_str(version, "VERSION");
  WRITE_HDR(VERSION, TYPE_STR);

  // TODO make a METRIC_STR from the METRIC def
  WRITE_HDR("MKS", TYPE_STR);

  // TODO equiv POLYTH? Rename
  #if METRIC == MKS
//  int derefine_poles = DEREFINE_POLES; WRITE_HDR(derefine_poles, TYPE_INT);
  #endif


  //int full_dump = (dump_id % DTf == 0 ? 1 : 0);
//  int full_dump = (dump_id % DTf == 0);
//  WRITE_HDR(full_dump, TYPE_INT);

  int electrons = ELECTRONS; WRITE_HDR(electrons, TYPE_INT);
  int radiation = RADIATION; WRITE_HDR(radiation, TYPE_INT);
  int nvar = NVAR; WRITE_HDR(nvar, TYPE_INT);
//  int nvar_passive = NVAR_PASSIVE; WRITE_HDR(nvar_passive, TYPE_INT);
//  int output_eosvars = OUTPUT_EOSVARS; WRITE_HDR(output_eosvars, TYPE_INT);

  WRITE_HDR(t, TYPE_DBL);
  WRITE_HDR(tf, TYPE_DBL);
  WRITE_HDR(nstep, TYPE_INT);
  int N1tot = N1TOT; WRITE_HDR(N1tot, TYPE_INT);
  int N2tot = N2TOT; WRITE_HDR(N2tot, TYPE_INT);
  int N3tot = N3TOT; WRITE_HDR(N3tot, TYPE_INT);
  WRITE_HDR(startx[1], TYPE_DBL);
  WRITE_HDR(startx[2], TYPE_DBL);
  WRITE_HDR(startx[3], TYPE_DBL);
  WRITE_HDR(dx[1], TYPE_DBL);
  WRITE_HDR(dx[2], TYPE_DBL);
  WRITE_HDR(dx[3], TYPE_DBL);
  #if (METRIC == MKS)
    WRITE_HDR(Rin, TYPE_DBL);
    WRITE_HDR(Rout, TYPE_DBL);
//    WRITE_HDR(Rout_vis, TYPE_DBL);
//    WRITE_HDR(Reh, TYPE_DBL);
    WRITE_HDR(Risco, TYPE_DBL);
    WRITE_HDR(hslope, TYPE_DBL);
    WRITE_HDR(a, TYPE_DBL);
    // TODO if POLYTH
//    WRITE_HDR(poly_xt, TYPE_DBL);
//    WRITE_HDR(poly_alpha, TYPE_DBL);
//    WRITE_HDR(mks_smooth, TYPE_DBL);
  #endif // METRIC

  WRITE_HDR(gam, TYPE_DBL);
  #if ELECTRONS
    WRITE_HDR(game, TYPE_DBL);
    WRITE_HDR(gamp, TYPE_DBL);
  #endif

  WRITE_HDR(cour, TYPE_DBL);
  WRITE_HDR(DTd, TYPE_DBL);
  WRITE_HDR(DTl, TYPE_DBL);
  WRITE_HDR(DTr, TYPE_DBL);
//  WRITE_HDR(DNr, TYPE_INT);
  WRITE_HDR(DTp, TYPE_INT);
//  WRITE_HDR(DTf, TYPE_INT);
  WRITE_HDR(dump_cnt, TYPE_INT);
  WRITE_HDR(dt, TYPE_DBL);
  WRITE_HDR(failed, TYPE_INT);

  #if NVAR_PASSIVE > 0
  //WRITE_(passive_type, TYPE_INT);
  {
    #define RANK (1)
    hsize_t fdims[RANK] = {NVAR_PASSIVE};
    hsize_t fstart[RANK] = {0};
    hsize_t fcount[RANK] = {NVAR_PASSIVE};
    if (!mpi_io_proc()) {
      fcount[0] = 0;
    }
    hsize_t mdims[RANK] = {NVAR_PASSIVE};
    hsize_t mstart[RANK] = {0};
    WRITE_ARRAY(passive_type, RANK, fdims, fstart, fcount, mdims, mstart,
      TYPE_INT);
    #undef RANK
  }
  #endif

  if(mpi_io_proc()) printf("Wrote header\n");

  PLOOP {
    WRITE_GRID(&(S->P[ip][0][0][0]), TYPE_FLOAT);
  }

  if(mpi_io_proc()) printf("Wrote prims\n");

//  {
//    hid_t prim_plist_id = H5Pcreate(H5P_DATASET_ACCESS);
//    hid_t prim_dset = H5Dopen(file_id, "S->P", prim_plist_id);
//    hid_t strtype = H5Tcopy (H5T_C_S1);
//    H5Tset_size(strtype, H5T_VARIABLE);
//    hsize_t str_dims[1] = {NVAR};
//    hid_t prim_space = H5Screate_simple(1, str_dims, NULL);
//    hid_t str_attr = H5Acreate(prim_dset, "vnams", strtype, prim_space,
//      H5P_DEFAULT, H5P_DEFAULT);
//    H5Awrite(str_attr, strtype, vnams);
//    H5Aclose(str_attr);
//    H5Sclose(prim_space);
//    H5Dclose(prim_dset);
//    H5Pclose(prim_plist_id);
//  }

  if (1) { // full dump // TODO all dumps full now
    #pragma omp parallel for collapse(3)
    ZLOOP_OUT divb[k][j][i] = flux_ct_divb(G, S, i, j, k);
    WRITE_GRID(divb, TYPE_FLOAT);

    if(mpi_io_proc()) printf("Wrote divb\n");

    #if OUTPUT_EOSVARS
    {
      #pragma omp parallel for collapse(3)
      ZLOOP_OUT {
	PRESS[k][j][i] = (gam-1.)*P[UU][k][j][i];
	TEMP[k][j][i] = PRESS[k][j][i]/P[RHO][k][j][i];
	ENT[k][j][i] = (gam-1.)*P[UU][k][j][i]*pow(P[RHO][k][j][i],-gam);
      }
      WRITE_GRID(PRESS, TYPE_FLOAT);
      WRITE_GRID(ENT, TYPE_FLOAT);
      WRITE_GRID(TEMP, TYPE_FLOAT);
    }
    #endif
    
    #if ELECTRONS
      WRITE_GRID(Qvisc, TYPE_FLOAT);
      #if RADIATION
        WRITE_GRID(Qcoul, TYPE_FLOAT);
      #endif
    #endif

    WRITE_GRID(fail_save, TYPE_INT);

    // TODO Current is tracked all the time -- slow?
    WRITE_VEC(S->jcon, TYPE_FLOAT);

  }

  H5Fflush(file_id, H5F_SCOPE_GLOBAL);
  H5Fclose(file_id);

//  if (mpi_io_proc()) {
//    write_xml_file(dump_id, t, vnams);
//  }

  dump_id++;
  fdump_id++;
//  reset_dump_variables(); // TODO what is this?

//  timer_stop(TIMER_OUT);
}

inline int index(int rank, double mdims[rank], int i, int j, int k, int mu, int nu) {
  if (rank == 3) {

  }
}

void write_array(void *data, const char *name, hsize_t rank,
  hsize_t *fdims, hsize_t *fstart, hsize_t *fcount, hsize_t *mdims,
  hsize_t *mstart, hsize_t type)
{
  hid_t filespace, memspace, plist_id, dset_id;
  filespace = H5Screate_simple(rank, fdims, NULL);
  H5Sselect_hyperslab(filespace, H5S_SELECT_SET, fstart, NULL, fcount, NULL);
  memspace = H5Screate_simple(rank, mdims, NULL);
  H5Sselect_hyperslab(memspace, H5S_SELECT_SET, mstart, NULL, fcount, NULL);
  plist_id = H5Pcreate(H5P_DATASET_CREATE);

  if(!(rank == 1 || rank == 3 || rank == 4 || rank == 5)) {
    fprintf(stderr, "Arrays of rank %lld not supported in HDF5 out!\n", rank);
    exit(-1);
  }

  int ntot = 1;
  for (int n = 0; n < rank; n++) {
    ntot *= mdims[n];
  }

  // We get to have a /lot/ of special cases here for reversing output wooooo
  int n = 0;
  if (type == TYPE_FLOAT) {
    float *buf = malloc(ntot*sizeof(float));
    printf("Allocating for %d\n",ntot);

    if (rank == 1) {
      for (n = 0; n < ntot; n++) {
	buf[n] = (float)(((double*)data)[n]);
      }
    } else if (rank == 3) {
      ZLOOP_TRANSPOSE {
	printf("Inserting %f", ((double*)data)[k*mdims[1]*mdims[0]+j*mdims[0]+i]);
	buf[n] = (float) (((double***)data)[k][j][i]);
	n++;
      }
    } else if (rank == 4) {
      ZLOOP_TRANSPOSE {
	DLOOP1 {
	  buf[n] = (float)(((double****)data)[mu][k][j][i]);
	  n++;
	}
      }
    } else if (rank == 5) {
      ZLOOP_TRANSPOSE {
	DLOOP2 {
	  buf[n] = (float)(((double*****)data)[mu][nu][k][j][i]);
	  n++;
	}
      }
    }
    printf("Filled with %d\n", n);

    dset_id = H5Dcreate(file_id, name, H5T_NATIVE_FLOAT, filespace, H5P_DEFAULT,
      plist_id, H5P_DEFAULT);
    H5Pclose(plist_id);
    plist_id = H5Pcreate(H5P_DATASET_XFER);
    H5Pset_dxpl_mpio(plist_id, H5FD_MPIO_COLLECTIVE);
    H5Dwrite(dset_id, H5T_NATIVE_FLOAT, memspace, filespace, plist_id, buf);
    free(buf);

  } else if (type == TYPE_DBL) {
    double *buf = malloc(ntot*sizeof(double));

    if (rank == 1) {
      for (int n = 0; n < ntot; n++) {
	buf[n] = (((double*)data)[n]);
	n++;
      }
    } else if (rank == 3) {
      ZLOOP_TRANSPOSE {
	buf[n] = (((double***)data)[k][j][i]);
	n++;
      }
    } else if (rank == 4) {
      ZLOOP_TRANSPOSE {
	DLOOP1 {
	  buf[n] = (((double****)data)[mu][k][j][i]);
	  n++;
	}
      }
    } else if (rank == 5) {
      ZLOOP_TRANSPOSE {
	DLOOP2 {
	  buf[n] = (((double*****)data)[mu][nu][k][j][i]);
	  n++;
	}
      }
    }

    dset_id = H5Dcreate(file_id, name, H5T_NATIVE_DOUBLE, filespace,
      H5P_DEFAULT, plist_id, H5P_DEFAULT);
    H5Pclose(plist_id);
    plist_id = H5Pcreate(H5P_DATASET_XFER);
    H5Pset_dxpl_mpio(plist_id, H5FD_MPIO_COLLECTIVE);
    H5Dwrite(dset_id, H5T_NATIVE_DOUBLE, memspace, filespace, plist_id, buf);
    free(buf);

  } else if (type == TYPE_INT) {
    int * buf = malloc(ntot*sizeof(int));

    if (rank == 1) {
      for (int n = 0; n < ntot; n++) {
	buf[n] = (((int*)data)[n]);
	n++;
      }
    } else if (rank == 3) {
      ZLOOP_TRANSPOSE {
	buf[n] = (((int***)data)[k][j][i]);
	n++;
      }
    } else if (rank == 4) {
      ZLOOP_TRANSPOSE {
	DLOOP1 {
	  buf[n] = (((int****)data)[mu][k][j][i]);
	  n++;
	}
      }
    } else if (rank == 5) {
      ZLOOP_TRANSPOSE {
	DLOOP2 {
	  buf[n] = (((int*****)data)[mu][nu][k][j][i]);
	  n++;
	}
      }
    }

    dset_id = H5Dcreate(file_id, name, H5T_NATIVE_INT, filespace,
      H5P_DEFAULT, plist_id, H5P_DEFAULT);
    H5Pclose(plist_id);
    plist_id = H5Pcreate(H5P_DATASET_XFER);
    H5Pset_dxpl_mpio(plist_id, H5FD_MPIO_COLLECTIVE);
    H5Dwrite(dset_id, H5T_NATIVE_INT, memspace, filespace, plist_id, buf);
    free(buf);

  } else if (type == TYPE_STR) {
    hid_t string_type = H5Tcopy(H5T_C_S1);
    H5Tset_size(string_type, strlen(data));
    plist_id = H5Pcreate(H5P_DATASET_CREATE);
    dset_id = H5Dcreate(file_id, name, string_type, filespace, H5P_DEFAULT,
      plist_id, H5P_DEFAULT);
    H5Pclose(plist_id);
    plist_id = H5Pcreate(H5P_DATASET_XFER);
    H5Dwrite(dset_id, string_type, memspace, filespace, plist_id, data);
  } else {
    fprintf(stderr, "type %llu not supported by write_array()! Exiting...\n",
      type);
    exit(-1);
  }
  H5Dclose(dset_id);
  H5Pclose(plist_id);
  H5Sclose(memspace);
  H5Sclose(filespace);
}

